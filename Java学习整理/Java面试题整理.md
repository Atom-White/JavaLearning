# Java面试整理--自用版

## 一、Java基础

### 1.引用数据类型

除了基本数据类型，其他都是引用数据类型。包括类、接口、数组，常见引用数据类型有`String`、`StringBuffer`、`HashSet`、`HashMap`、`ArrayList`

### 2.==与equals的区别

- ==：对于基本数据类型比较的是内容，对于引用数据类型，比较的是地址值
- equals：用来比较两个对象的内容是否相等

特别的：equals默认是比较的引用类型变量的地址值，String、Integer、Date类库中已经被重写

### 3.重载和重写的区别

- 重载：发生在同一个类中，方法名相同，参数类型不同、个数不同、顺序不同
- 重写：发生在父子类中，方法名、参数列表必须相同，抛出的异常范围小于等于父类

### 4.String、StringBuffer、StringBuilder三者区别

- String：字符串常量
- StringBuffer：字符串变量（加了同步锁，线程安全）
- StringBuilder：字符串变量（非线程安全）

### 5.单例模式

单例模式：某个类的实例在多线程环境下只会被创建一次出来

饿汉式：线程安全，一开始就初始化

懒汉式：非线程安全，延迟初始化

双检锁：线程安全，延迟初始化

### 6.反射

- 作用：反射机制允许程序在运行过程中动态的创建对象、调用方法。
- 原理：通过调用方法，得到其class对象，进而知道此类的所有方法、属性，程序运行过程中也能够对其进行各种设置操作
- 应用场景：工厂模式当中，如bean工厂模式就是应用了反射；如springboot框架中的@Component注解，由spring创建对象；如
- 优势：降低了耦合度，增加了可拓展性。

### 7.jdk8新特性

1. Lambda表达式
2. 接口允许定义默认方法和静态方法
3. 函数式接口
4. 日期、时间类的改进
5. 内置了Base64编码器和解码器
6. Stream API

### 8.java中的异常

Throwable：所有异常的根

Error：系统内部和资源耗尽的错误

Exception：包括运行时异常和检查异常

### 9.BIO、NIO、AIO的区别

- BIO：同步阻塞IO, 适用于连接数目比较小且固定的架构 ，如tomcat
- NIO：同步非阻塞IO, 适用于连接数目多且连接比较短（轻操作）的架构 ,如聊天服务器
- AIO：NIO的升级，异步非阻塞IO， 适用于连接数目多且连接比较长（重操作）的架构 ，如相册服务器

### 10.ThreadLocal原理

`ThreadLocal`应用于多线程中，为共享变量在每个线程中创建一个副本。是除了加锁这种同步方式以外的保证线程安全的一种方法。

与锁机制进行对比的话，`ThreadLocal`是以空间换时间，锁机制是以时间换空间。

**原理：** 每个线程内都有一个`ThreadLocalMap`，当创建一个`ThreadLocal`的时候，就会将该`ThreadLocal`对象添加到该Map中，其中键就是`ThreadLocal`，值就是要共享的变量。

**内存泄漏问题：**因为`ThreadLocalMap`中的key为弱引用，所以当垃圾回收器（gc）工作的时候，就会将其回收，但是对应的value仍然存在。为了解决这个问题，我们使用完`ThreadLocal`之后调用remove方法

### 11.锁的分类

**同步锁：**在多线程中，多线程同时访问统一数据，这样容易出现各种问题，为了避免这种情况，我们要保证线程同步互斥，在同一时间只允许一个线程访问共享数据，就可以用synchronized给共享的数据加同步锁。

**死锁：**在多线程中，多个线程都在请求其他线程所持有的资源，线程被无限期阻塞。

**悲观锁：**悲观锁认为对于同一个数据的并发操作，一定会发生修改，（自己使用数据的时候，其他线程一定会来修改数据），因此获取数据之前会先加锁。适用于写操作比较多的场景。

**乐观锁：**乐观锁认为自己在使用数据的时候不会有别的线程修改数据，所以不会加锁，只有自己更新数据的时候会检查有没有其他线程更新了数据。

### 12.mysql中的锁的分类

- **按锁的粒度：**表级锁、行级锁、页级锁（表级锁速度快，冲突多，行级锁速度慢，冲突少，折中页面锁）
- **按锁的级别：**共享锁、排他锁
- **按加锁方式：**自动锁、显式锁
- **按操作划分：**DML锁（对数据进行操作的锁）、DDL锁（对表结构进行变更的锁）
- **按使用方式划分：**悲观锁、乐观锁

### 13.MyISAM和InnoDB存储引擎关于锁方面的区别

- `MyISAM`采用表级锁，`InnoDB`支持行级锁和表级锁，默认行级锁
- `MyISAM`适用场景：频繁执行全表count语句，增删频率不高，查询非常频繁；`InnoDB`适用场景：数据增删改查都比较频繁，支持事务，可靠性高

### 14.volatile

volatile是轻量级的synchronized，保证了不同线程对于共享变量操作的内存可见性，禁止指令重排序。

**内存可见性：**可见性是指一个线程修改了共享变量的值，其他县城能够立即得知这个修改。普通变量对工作内存的值修改后，同步到主内存的时间是不确定的，而volatile保证新值能够例课同步到主内存，使用时也从主内存中刷新。

**指令重排：**cpu和编译器为了提高程序执行的效率，会按照一定的规则进行指令优化，但是代码逻辑之间是存在一定的先后顺序的，并发执行时按照不同的执行逻辑会得到不同的结果。

### 15.volation与synchronized的区别

- volatile本质上是在告诉JVM当前变量的值是不确定的，每次需要从主存中读取；synchronized是锁定当前变量只能在当前线程中才可以使用，其他线程被阻塞
- volatile尽可以用在变量级别，synchronized可以用在变量、方法和类上
- volatile仅能保证变量修改的可见性，synchronized可以保证变量修改的可见性与原子性
- volatile不能造成线程阻塞，synchronized可能造成线程阻塞
- volatile标记的变量不会被编译器优化（指令重排），synchronized标记的变量可以被编译器优化

### 16.volatile的使用场景

单例模式中的双重检查锁定

读操作远大于写操作的情况下

用于状态标志

### 17.List、Map、Set的区别

- List和Set是存储单列数据的集合，Map是存储键和值这样双列数据的集合
- List中存储的数据是有顺序的，并且值允许重复；
- Map中存储的数据是无序的，并且键不允许重复，但是值允许重复
- Set中存储的数据是无顺序的，并且不允许重复，但是元素在集合中的位置是由元素的hashcode决定的，即位置固定，但是对于用户来说位置不能决定。

### 18.HashMap底层原理

- HashMap底层是由数组+链表+红黑树实现的，当链表中的元素超过8个以后，会将链表转化为红黑树，当红黑树节点小于等于6时，又会退化为链表
- 当new HashMap（）时，底层没有创建数组，首次调用put（）方法时，底层会创建长度为16的数组
- 默认负载因子为0.75，也就是说当HashMap中的元素个数超过12的时候，就把数组大小扩容到32，即扩大一倍
- 如果我们提前预知HashMap中元素个数，预设元素个数能够有效提高性能，如果有1000个元素，预设2048，因为1000/1024>0.75

### 19.泛型的优点

- 泛型即为编写的代码可以为不同类型的对象所重用，如ArrayList就是一个泛型类，其作为集合可以存放Integer、String等各种类型
- 好处：使用泛型的好处在于我们不必因为添加的元素不同而定义不同类型的集合，如整型集、浮点型集、字符串型集，他们都属于object。更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。

### 20.如何选用集合类

1. 根据键值对获取到元素值时选用Map接口下的集合

   - 需要排序选择TreeMap

   - 不需要排序选择HashMap

   - 需要保证线程安全选用ConcurrentHashMap

2. 需要存放元素值时，选用collection接口下的集合

   - 需要保证元素唯一使用Set
   - 不需要使用实现List的接口，如ArrayList

### 21.HashSet如何检查重复

当我们把对象加入到HashSet，会先计算该对象的hashcode值来判断对象加入的位置，同时与其他加入对象的hashcode值作比较，如果没有相同的hashcode，则判断该对象没有重复。如果有相同的就调用equals()方法对比对象的内容。

### 22.数组（Array）和列表（ArrayList）的区别

- Array可以包含基本类型和对象类型，ArrayList只能包含对象类型
- Array只能存储同种类型元素，ArrayList可以存储不同类型的
- Array大小是固定的，ArrayList大小是动态变化的

### 23.红黑树的特征

1. 每个节点都是红色或者黑色
2. 根节点为黑色
3. 每个空的叶子节点都是黑色
4. 如果一个叶子节点是红色，那么其叶子节点必须是黑色
5. 从一个节点到该节点的子孙节点的所有路径包含相同数目的黑节点

### 24.常见的RuntimeException

- `java.lang.NullPointerException` 空指针异常;出现原因:调用了未经初始化的对象
  或者是不存在的对象。
- `java.lang.NumberFormatException` 字符串转换为数字异常;出现原因:字符型数据中包含非数字型字符。
- `java.lang.IndexOutOfBoundsException` 数组角标越界异常，常见于操作数组对象时发生。
- `java.lang.NoSuchMethodException` 方法不存在异常。
- `java.lang.ClassCastException` 数据类型转换异常

运行时异常：都是RuntimeException类及其子类异常，是不检查异常。

非运行时异常：RuntimeException以外的异常，类型上属于Exception类及其子类。必须经过处理，否则编译不通过。

### 25.Error和Exception的区别

- Error 表示系统级的错误和程序不必处理的异常，总是不可控制的，常见的 `OutOfMemoryError` 之类
- Exception 表示需要捕捉或者需要程序处理的异常，一般是由程序员导致的错误。可分为运行时异常和非运行时异常

### 26.Java 注解可以加在什么地方？Java 自带注解有哪些？哪里有用到注解？

- 注解用于对代码的说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解
- Java自带的标准注解有：@Override、@Deprecated、@SuppressWarnings，用这些注解标明后编译器就会检查
- **注解常用场景：**Spring、SpringMVC中的大量注解

### 27.Java中的final关键字

Java中final关键字可以修饰类、方法、属性，修饰类时不能被继承，修饰方法时不能被子类重写，修饰属性时，该属性就是一个常量，一旦初始化不能修改

## 二、多线程

### 1.线程与进程

- **进程：**进程是程序的一次执行过程，是系统运行程序的基本单位，是系统进行资源分配和调度的基本单位。进程是动态的，系统运行一个程序就是一个进程创建、运行到消亡的过程。
- **线程：**线程是更小的执行单位，程序执行的最小单位，运算调度的最小单位，进程在执行过程中可以产生多个线程，多个线程共享进程的堆和方法区资源。

### 2.并发与并行

- **并发：**同一时间段，多个任务在执行
- **并行：**同一时刻，多个任务同时执行

### 3.多线程带来的问题

内存泄露、上下文切换、死锁

受限于硬件和软件的资源闲置问题

### 4.线程的生命周期

初始状态、运行状态、阻塞状态（没有拿到锁）、等待状态（依赖其他线程的唤醒）、超时等待、终止状态

### 5.上下文切换

多线程中，一般线程数大于cpu数，那么采用时间片轮转方法运行线程，当一个线程的时间片用完时候就会进入到就绪状态，把cpu让给其他线程，这就是一次上下文切换。

### 6.线程死锁

多个线程同时被阻塞，都在等在其他线程释放资源，造成线程被无限期阻塞。

产生死锁的四个条件：

1. 互斥条件
2. 请求与保持条件
3. 不剥夺条件
4. 循环等待条件

### 7.sleep与wait方法的区别与共同点

- 两者都可以暂停线程的执行
- wait方法释放了锁，而sleep方法没有释放锁
- wait方法调用后线程不会自动苏醒，需要其他线程调用notify方法，sleep方法执行后，线程会自动苏醒

### 8.为什么多线程中调用start方法而不是调用run方法

调用start方法，线程会进入就绪状态，只要得到时间片就可以运行了。而run方法其实只是Thread的一个普通方法，其实是在主线程中执行。

### 9.synchronized关键字

synchronized关键字是为了解决多个线程访问资源的同步性问题，synchronized关键字能够保证其修饰的方法或者代码块在任意时刻只有一个线程执行。

### 10.synchronized使用方式

- 修饰实例方法
- 修饰静态方法
- 修饰代码块
- 修饰类

### 11.synchronized和ReentrantLock

1. 两者都是可重入锁
2. synchronized依赖于JVM，而ReentrantLock依赖于API
3. ReentrantLock使用上更为灵活，包括公平锁与非公平锁

### 12.池化技术

池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。

### 13.线程池好处

- 降低资源消耗
- 提高响应速度
- 提高线程的可管理性

### 14.Runable和Callable接口的区别

1. Callable接口后来出现，是为了解决Runable不支持的用例
2. Runable接口不会返回结果或抛出检查异常，但是Callable可以

### 15.创建线程的几种方式

- 继承Thread类并重写run方法创建线程，实现简单，但是不能继承其他类
- 实现Runable接口并重写run方法，解决了单继承局限性的问题，实现解耦
- 实现Callable接口并重写了call方法，创建线程。可以获取线程执行结果的返回值
- 使用线程池创建（使用 `java.util.concurrent.Executor` 接口）

### 16.线程池的重要参数

1. `corePoolSize`：线程池核心线程数量
2. `maximumPoolSize`：线程池最大数量
3. `keepAliveTime`：空闲线程存活时间，如果一个线程处于空闲状态，并且当前线程数量大于`corePoolSize`，那么在指定时间后，这个空闲线程就会被销毁
4. `unit：keepAliveTime`的单位
5. `workQueue`：线程池所使用的缓冲队列，新任务被提交后会先进入工作队列，等待调度
6. `threadFactory`：线程工厂，用于创建线程，一般用默认的即可
7. `handler`：拒绝策略，当任务太多来不及处理，如何拒绝任务

### 17.线程池的使用方式

`Excutors`创建线程池的4种方式：

1. `newSingleThreadExecutor`：只会创建一个线程执行任务

***

## 三、SpringBoot

## 四、JVM

***

## 五、技术框架

### 1.消息中间件kafka

#### 1.1 kafka与其他消息中间件相比的特点

- **优点：**高吞吐量、高并发、低延迟、持久性、可靠性（消息会被持久化到本地磁盘，支持数据备份，防止数据丢失）

- **缺点：**使用上较为复杂，可能存在消费重复的问题、多分区情况下消息乱序问题

#### 1.2 kafka的使用场景

- **消息系统：**解耦、生产者和消费者、缓存消息

- **日志收集：**可以通过设置将操作⽇志"批量""异步"的发送到kafka集群中,⽽不是保存在本地或者数据库中;kafka可以批量提交消息/压缩消息等,这对生产者端⽽⾔,⼏乎感觉不到性能的开⽀
